# AUTOGENERATED! DO NOT EDIT! File to edit: nbdev/04_Trainer.ipynb (unless otherwise specified).

__all__ = ['fn', 'pipe', 'Tensorify', 'AudioDataset', 'dataset', 'dataloader', 'dataiter', 'data', 'n_epochs',
           'n_samples', 'n_iter', 'model']

# Cell
from .core import *
from .pipe import *
from .utils import *
from .data import *
from .imports import *
from .models import *

# Cell
from torch.utils.data import Dataset, DataLoader
import torch
import torchvision

# Cell
fn = Path("../data/esc50_sample/")
pipe = AudioPipe(fn)

# Cell
class AudioDataset(Dataset):
    @delegates(AudioPipe)
    def __init__(self, fn, **kwargs):
        self.fn = fn
        self.pipe = AudioPipe(fn)
        self.n_samples = len(get_audio_files(fn))

    def __getitem__(self, index):
        x,y = self.pipe(index)
        x,y = ToTensor()(x)[:,:208],ToTensor()(y) #Hack add multiple or padding to pipeline
        return x,y

    def __len__(self):
        return self.n_samples

# Cell
dataset = AudioDataset(fn)
dataloader = DataLoader(dataset=dataset, batch_size=4, shuffle=True, num_workers=2)

dataiter = iter(dataloader)

# Cell
data = dataiter.next()

Tensorify = ToTensor()

# Cell
n_epochs = 1
n_samples = len(dataset)
n_iter = math.ceil(n_samples/4)

# Cell
model = U_Net(img_ch=2, output_ch=4)
model.train();

# Cell
for epoch in range(n_epochs):
    for i, (mixed, specs) in enumerate(dataloader):
        xb,yb = Tensorify
        if (i+1)%5==0:
            print(f'epoch {epoch}: step {(i+1)/n_iter}')
        out = model(xb)
        mask1 = MaskcIRM(out[:,:2,:,:])
        mask2 = MaskcIRM(out[:,2:,:,:])
        sepspecs = mask1*mixed, mask2*mixed
        loss = loss_func(out, yb)
        loss.backward()
        optimizer.step()
        optimizer.zero_grad()